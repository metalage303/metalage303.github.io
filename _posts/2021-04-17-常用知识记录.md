---
layout: post
title: 常用知识记录
description: 
tags: 随笔
---

# Centos 常用小技巧
- 查看系统中有哪些用户：`cut -d : -f 1 /etc/passwd`

- 删除用户：`userdel -rf name`

- 修改权限：`chmod -R 777 dir` （将dir整体变为777，常用0700）

- 修改所有者： `chown -R www:www /html` (将html目录所有者变成www组的www用户)

- 删除目录：`rm -rf dir` (整体删除dir)

- 拷贝目录：`cp -r -a ./* /dir` (将当前路径下所有文件包括子目录全部拷贝到dir)

- 解压gz文件：`tar -xvzf filename` (解压缩gz文件)

- 解压gz文件：`gzip -d filename` (解压缩gz文件) 

- 解压zip文件：`unzip -x filename` (解压缩zip文件)

- 压缩为zip：`zip -r filename.zip ./*`

- 查看centos发行版本： `cat /etc/centos-release`

- tar压：`tar -zcvf backup.tar.gz ./*`

- tar解：`tar -xzvf backup.tar.gz`

- nohup后台运行程序不要任何输出：`nohup ./program >/dev/null 2>&1 &`

- **关闭firewalld:**

  `systemctl stop firewalld`
  `systemctl disable firewalld`
  `systemctl mask firewalld`

-  **关闭 selinux**：
  `nano /etc/selinux/config`
  	> SELINUX=disabled
  	存盘退出, 需要重启。
- **添加路径到系统PATH**
  `nano ~/.bash_profile`
  > 在PATH=$PATH这行尾部加上:/usr/local/nginx/sbin
  > 存盘退出。
  
  让设置生效：`source ~/.bash_profile`

- **crontab自动定时执行，也可以用来设置自启动：**

  输入 `crontab -e` 加一行:

  > @reboot sleep 5;/root/autoexec.sh
  > 存盘退出
- **最基础的nftables防火墙脚本：**
编辑脚本：`nano basic.nft`
	```bash
	flush ruleset
	table inet filter {
	        chain input {
	                type filter hook input priority 0; policy drop;
	                ct state established,related accept
	                ct state invalid drop
	                iif lo accept
	                ip protocol icmp icmp type { destination-unreachable, router-solicitation, router-advertisement, time-exceeded, parameter-problem } accept
	                ip protocol igmp accept
	                //放行3个端口：
	                tcp dport { ssh, http, https} accept
	        }
	        chain forward {
	                type filter hook forward priority 0; policy drop;
	        }
	        chain output {
	                type filter hook output priority 0; policy accept;
	        }
	}

	存盘退出
	```
	加载防火墙：``	nft -f basic.nft``
	
	
----

# MySQL小技巧

- **mysql备份与恢复**
  无需登录：
  备份数据库：`mysqldump -uroot -p'密码' 库名 > /文件名.sql`
  还原数据库：`mysql -uroot -p'密码' 库名 < /文件名.sql`

----

- **删库（需要先登录MySQL）：**
  `DROP DATABASE 库名;`

----

- **建库：**
  `CREATE DATABASE 库名 CHARACTER SET utf8 COLLATE utf8_general_ci;`

----

- concat 和 group_concat

  **concat**的原始作用非常简单，就是合并两个或多个字符串，例如：

  ```sql
  SELECT
  	concat('Hello',' World') as output
  ```

  output列输出：Hello World，就这样。

  如果在concat的表达式里嵌入子查询，这就很有用了，例如：

  ```sql
  SELECT 
  	concat(order.nameid,'|',(Select `name` from `namelist` where order.nameid = namelist.id)) As output 
  	FROM `order` Where nameid = 123
  ```

  假设存在一个order表和namelist表，order表存有nameid，现在想将其对应的name也取出来，通常我们会用一个子查询去做这件事，但是如果不想将两者作为两个单独的列返回，则可以采用concat方法来合并这两个列。本例中，output列返回： 123|Tom

  ----

  **group_concat** 的作用类似concat，但是当子查询的结果超过一个的时候，group_concat可以将多重结果默认用逗号串起来：

  ```sql
  SELECT 
  	group_concat(order.nameid,'|',(Select `name` from `namelist` where order.nameid = namelist.id)) As output 
  	FROM `order` Where nameid >= 123
  ```

  还是之前那个列子，但是改为了group_concat，这种情况下，如果返回的记录不止一个，则变成这样：

  123|Tom, 124|Alice, 125|Ivan

  注意：逗号是系统默认添加的，每一个逗号分隔了一行记录，group_concat在处理子查询中出现多重记录的时候很有用。

  这里再顺便说说前端JS怎么处理：

  ```javascript
  items = JSON.parse(response.data)
  let i, j, namelist, name
  for (i in items) {
  	namelist = items[i].output(",")
  	for (j in namelist) {
  		name = namelist[j].split("|")
  		console.log(name)
  	}
  }
  ```

  简单地将结果用split切割为独立的数组即可，第一次切割是将不同的姓名分开（使用逗号），第二次切割是将nameid和name切开（使用|号），最终：

  name[0] 得到的就是某一个人的nameid， name[1] 就是其name

----

# 无法归类的小技巧

- **如何移植一个phpbb论坛?**

  首先在新环境上安装好php和nginx，

  将旧的phpbb全部html文件拷贝到/usr/local/nginx/html

  通过上面的数据库还原方式，将老数据恢复好。

  然后修改html目录权限：
  `chmod -R 0700 /usr/local/nginx/html`
  `chown -R www:www/usr/local/nginx/html`

  能够登录后台后第一件事情是Purge the cache和Purge all sessions

  如果直接不能通过域名访问littledot.net，需要：

  `nano /usr/local/nginx/conf/nginx.conf`

  > 在index.html 前面加上 index.php，注意：https部分也许如此

  有时候浏览器无法访问网站，不是设置的问题，而是没有清空本地浏览器缓存导致，尝试整体清空一次问题即可解决。

----

- **如何申请Let's Encrypt证书**

  参考网站1：https://letsencrypt.org/

  参考网站2：https://certbot.eff.org/lets-encrypt/centosrhel8-nginx

  依次输入以下命令：

  ```bash
  dnf -y install snapd (Snap包是新应用格式包, 通过snapd来安装使用snap应用)
  systemctl enable --now snapd.socket
  ln -s /var/lib/snapd/snap /snap
  snap version
  snap changes
  snap change 1
  snap list
  snap install core
  snap refresh core
  dnf -y remove certbot
  snap install --classic certbot
  ln -s /snap/bin/certbot /usr/bin/certbot
  certbot certonly --nginx --nginx-server-root /usr/local/nginx/conf/ --nginx-ctl /usr/local/nginx/sbin/nginx 
  ```

  > --nginx-server-root为nginx设置文件路径, 
  >
  > --nginx-ctl 为nginx可执行文件路径，
  >
  > 如果是通过yum或者dnf安装的nginx，则这两个选项可以忽略。

  公钥默认路径： `/etc/letsencrypt/live/littledot.net/fullchain.pem`

  私钥默认路径： `/etc/letsencrypt/live/littledot.net/privkey.pem`

  测试证书自动更新：`certbot renew --dry-run`

  利用crontab自动更新证书，每天检查两次，在 01:00 和 13:00：

  输入：`crontab -e` 加一行：
  `6 1,13 * * * certbot renew --renew-hook "systemctl restart nginx"`

  通过这个命令可以查看各种定时器：`systemctl list-timers`

  有了证书之后，我们还需要为nginx设置https服务：
  `nano /usr/local/nginx/conf/nginx.conf`

  > 查找： HTTPS server 这部分，修改为： 

  ```bash
    # HTTPS server
    #
    server {
        listen       443 ssl;
        server_name  localhost;
  
        ssl_certificate      /etc/letsencrypt/live/littledot.net/fullchain.pem;
        ssl_certificate_key  /etc/letsencrypt/live/littledot.net/privkey.pem;
      
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
      
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
      
        location / {
            root   html;
            index  index.php index.html index.htm;
        }
      
        location ~ \.php$ {
            root           html;
            fastcgi_pass   unix:/var/run/php-fpm.sock;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        }
    }
  ```

  存盘退出，输入：`systemctl restart nginx` 重启nginx生效。

----

- **如何利用nginx反向代理实现多域名映射到同一台服务器的80端口？**

  `nano /usr/local/nginx/conf/nginx.conf`

  > 在这个文件里新开一个server，注意要放到http这个最外层的花括号内部，
  >
  > 每一个域名单独用一段完整的server {} 包裹，当然，前提条件是这些域名都必须解析到同一个IP

  ```bash
      server {
         listen       80;  //一个nginx可以监听多个80端口
         server_name  abc.net; 
         //如果是浏览器输入的是abc.net，则在此做相应处理。
  
        location / {
            //设置根目录，注意如果网站放在/root内，需要做权限处理
            root   /root/website/public; 
            //如果网址不带任何参数，则访问默认文件helloworld.html
            index  helloworld.html;
        }
        //如果带参数，例如：abc.net/order，则映射到本机的其他地址
        //这些地址可以是Java的也可以是nodejs的API接口，也可以是静态页面，但必须是能够访问的页面。
        location /order {
             proxy_pass http://127.0.0.1:3000/order;
        }
      }
  ```

  如果你嫌一个一个路径去设置很麻烦，也可以在location里采用正则：

  ```
      location ~ /(.*) {
           proxy_pass http://127.0.0.1:3000/$1;
      }
  ```

  > 尽管不建议，但是如果你非要把网站设置放在/root里，要先执行chgrp www /root，否则会报权限错误（此www是指你安装php和nginx为系统添加的操



